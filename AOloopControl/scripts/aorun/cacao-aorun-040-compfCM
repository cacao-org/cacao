#!/usr/bin/env bash

# This script uses milk-argparse
# See template milk-scriptexample in module milk_module_example for template and instructions

# temp directory for intermediate steps
cfCMtmpdir="compfCM"

# script 1-line description
MSdescr="Re-order control modes according to spatial frequency"

CMmDM="./conf/CMmodesDM/CMmodesDM.fits"
CMmWFS="./conf/CMmodesWFS/CMmodesWFS.fits"
DMmask="./conf/dmmask.fits"
WFSmask="./conf/wfsmask.fits"
zrespm="./conf/RMmodesWFS/zrespM-H.fits"

MSextdescr="Takes as input the control modes (CM) expressed in DM and WFS space
Re-orders the CM by rotations to match spatial frequency ordering.
Uses temporary directory ./${cfCMtmpdir}/

Input files read by script :
	$CMmDM
	$CMmWFS
	$DMmask
	$WFSmask
	$zrespm
"

source milk-script-std-config
source cacao-check-cacaovars


MSopt+=( "g:GPUdevice:setGPUdevice:GPUdevice[int]:Set GPU device, -1 for CPU [-1]" )
GPUdevice="-1"
function setGPUdevice()
{
	GPUdevice=$1
}

MSopt+=( "c:CPAmax:setCPAmax:cpamax[float]:max cycles per aperture (CPA)[8]" )
CPAmax="8"
function setCPAmax()
{
	CPAmax=$1
}

MSopt+=( "z:NBzer:setNBzer:NBzer[int]:Set number of Zernike polynomials [5]" )
NBzer=5
function setNBzer()
{
	NBzer=$1
}

SVDlim="0.1"
MSopt+=( "s:SVDlim:setSVDlim:SVDlim[float]:Set SVD limit for pseudoinverse [${SVDlim}]" )
function setSVDlim()
{
	SVDlim=$1
}


SVDelim="0.1"
MSopt+=( "e:SVDelim:setSVDelim:SVDelim[float]:Set SVD extrapolation limit [${SVDelim}]" )
function setSVDelim()
{
	SVDelim=$1
}


source milk-argparse

# Re-order control modes in increasing spatial frequency by multidimentional rotation


# Input
#
# by convention:
# CMmodesWFS is orthogonal over wfsmask
# CMmodesDM is norm2 normalized over dmmask
#
#maxSVDmode=80
#CMmDM="conf/CMmodesDM/CMmodesDM.fits[*,*,1:${maxSVDmode}]"
#CMmWFS="conf/CMmodesWFS/CMmodesWFS.fits[*,*,1:${maxSVDmode}]"





mkdir -p ${cfCMtmpdir}





########################################################################
#
# TARGET MODES
#
########################################################################

# Create set of Fourier modes, store as modesF.fits
#
#CACAO_DMxsize=12
#CACAO_DMysize=12
#CACAO_DM_beam_rad=5.5
x0default=$(echo "scale=3; $CACAO_DMxsize/2-0.5" | bc)
y0default=$(echo "scale=3; $CACAO_DMysize/2-0.5" | bc)
r0default=$(echo "scale=3; 0.450*$CACAO_DMxsize" | bc)


# 2D defaults
DMsizex=${CACAO_DMxsize}
DMsizey=${CACAO_DMysize}
DMx0=${CACAO_DM_beam_xcent:-$x0default}
DMy0=${CACAO_DM_beam_ycent:-$y0default}
DMr0=${CACAO_DM_beam_rad:-$r0t}


DMr0="28.0"
echo "DMx0 = $DMx0"
echo "DMy0 = $DMy0"

echo "DMr0 = $DMr0"





# Create DM-space modes ordered by spatial frequency
# First modes are Zernikes, then Fourier
# Modes are not orthogonal
#
# This is the target ordering to which the new control modes should 
# match as well as possible
#
# output modesZFn.fits
#
milk-all << EOF
zern.mkzerc .radmaskfact 1.1
zern.mkzerc modesZ ${DMsizex} ${DMsizey} ${DMx0} ${DMy0} ${DMr0} ${NBzer}
saveFITS modesZ "./${cfCMtmpdir}/modesZ.fits"
lintools.mkFouriermodes .align.centered 0
lintools.mkFouriermodes .align.xcenter ${DMx0}
lintools.mkFouriermodes .align.ycenter ${DMy0}
lintools.mkFouriermodes .rCPAmin 0.1
loadfits "${DMmask}" dmmask
lintools.mkFouriermodes .maskim dmmask
lintools.mkFouriermodes .extrfactor 0.5
lintools.mkFouriermodes .extroffset 3.5
lintools.mkFouriermodes modesF ${DMsizex} ${DMsizey} ${CPAmax} 0.8 ${DMr0} 1.2 0
saveFITS modesF "./${cfCMtmpdir}/modesF.fits"
immerge modesZ modesF modesZF 2
saveFITS modesZF "./${cfCMtmpdir}/modesZF.fits"
modesZFm=modesZF*dmmask
normalizeslice modesZF dmmask modesZFn 2
listim
saveFITS modesZFn "./${cfCMtmpdir}/modesZFn.fits"
saveFITS pixdist "./${cfCMtmpdir}/pixdist.fits"
exitCLI
EOF









########################################################################
#
# EXTRAPOLATION MODES
#
########################################################################

#
# Build modal decomposition for spatial extrapolation in DM space
#
# Perform PCA of modesZFn.fits by SVD
#
# modes :         modesZFnmU
# extended modes: modesZFnmUe
#
milk-all << EOF
loadfits "./${cfCMtmpdir}/modesZFn.fits" modesZFn
loadfits "${DMmask}" dmmask
modesZFnm=modesZFn*dmmask
linalg.compSVD .GPUdevice ${GPUdevice}
linalg.compSVD modesZFnm modesZFnmU modesZFnmS modesZFnmV ${SVDelim}
saveFITS modesZFnmU "./${cfCMtmpdir}/modesZFnmU.fits"

linalg.sgemm .GPUdevice ${GPUdevice}
linalg.sgemm .transpA 0
linalg.sgemm .transpB 0
linalg.sgemm modesZFn SVDvnmodes out
saveFITS out "./${cfCMtmpdir}/modesZFnmUe.fits"
listim
exitCLI
EOF



# OPTIONAL
# Check orthogonality in DM space
#
#milk-all << EOF
#linalg.sgemm .GPUdevice ${GPUdevice}
#loadfits "./${cfCMtmpdir}/modesZFnmU.fits" modesZFnmU
#linalg.sgemm .transpA 1
#linalg.sgemm modesZFnmU modesZFnmU out
#saveFITS out "./${cfCMtmpdir}/modesZFnmU_xp.fits"
#exitCLI
#EOF



# Compute WFS response to modesZFn over wfsmask -> modesZFnWFSm.fits
#
cacao << EOF
loadfits "${zrespm}" zrespM
loadfits "./${cfCMtmpdir}/modesZFn.fits" modesZFn
cacaocc.generateRMWFS zrespM modesZFn modesZFnWFS
saveFITS modesZFnWFS "./${cfCMtmpdir}/modesZFnWFS.fits"
loadfits "${WFSmask}" wfsmask
modesZFnWFSm=modesZFnWFS*wfsmask
saveFITS modesZFnWFSm "./${cfCMtmpdir}/modesZFnWFSm.fits"
exitCLI
EOF











########################################################################
#
# CONTROL MODES
#
########################################################################


# COMPUTE CONTROL MODES FROM Z-RESPM
#

# Perform PCA of zespM.fits by SVD
#
# The output is ordered by singular value
# This is not a friendly ordering, spatial frequency is not preserved
# The first modes are NOT low-order mores :(
#
milk-all << EOF
loadfits "${zrespm}" zespM
loadfits "${WFSmask}" wfsmask
zespMm=zespM*wfsmask
linalg.compSVD .GPUdevice ${GPUdevice}
linalg.compSVD .Vdim0 ${DMsizex}
linalg.compSVD zespMm mFsvdU mFsvdS mFsvdV ${SVDlim}
saveFITS SVDunmodes "./${cfCMtmpdir}/CMmWFS.fits"
loadfits "${DMmask}" dmmask
mFsvdVm=mFsvdV*dmmask
saveFITS mFsvdVm "./${cfCMtmpdir}/CMmDM.fits"
listim
exitCLI
EOF


# Renormalize modes in WFS space
#
# Input: 
# - CMmDM   : control modes in DM space, unity RMS over dmmask
# - CMmWFS  : control modes in WFS space, orthogonal basis
# 
# Output:
# - CMmDMn  : control modes in DM space
# - CMmWFSn : control modes in WFS space, orthonormal basis over wfsmask
#
milk-all << EOF
loadfits "./${cfCMtmpdir}/CMmDM.fits" CMmDM
loadfits "./${cfCMtmpdir}/CMmWFS.fits" CMmWFS
loadfits "${WFSmask}" wfsmask
normalizeslice .auxin CMmDM
normalizeslice CMmWFS wfsmask CMmWFSn 2
saveFITS CMmWFSn "./${cfCMtmpdir}/CMmWFSn.fits"
saveFITS CMmDM "./${cfCMtmpdir}/CMmDMn.fits"
exitCLI
EOF


# OPTIONAL
# Check orthonormality in WFS space (input)
#
milk-all << EOF
linalg.sgemm .GPUdevice ${GPUdevice}
loadfits "${WFSmask}" wfsmask
loadfits "./${cfCMtmpdir}/CMmWFS.fits" CMmWFS
CMmWFSm=CMmWFS*wfsmask
linalg.sgemm .transpA 1
linalg.sgemm CMmWFSm CMmWFSm out
saveFITS out "./${cfCMtmpdir}/CMmWFS_mxp.fits"
exitCLI
EOF

# OPTIONAL
# Check orthonormality in WFS space (output)
#
milk-all << EOF
linalg.sgemm .GPUdevice ${GPUdevice}
loadfits "${WFSmask}" wfsmask
loadfits "./${cfCMtmpdir}/CMmWFSn.fits" CMmWFSn
CMmWFSnm=CMmWFSn*wfsmask
linalg.sgemm .transpA 1
linalg.sgemm CMmWFSnm CMmWFSnm out
saveFITS out "./${cfCMtmpdir}/CMmWFSn_mxp.fits"
exitCLI
EOF

# OPTIONAL
# Check orthonormality in DM space (input)
#
milk-all << EOF
linalg.sgemm .GPUdevice ${GPUdevice}
loadfits "${DMmask}" dmmask
loadfits "./${cfCMtmpdir}/CMmDM.fits" CMmDM
CMmDMm=CMmDM*dmmask
linalg.sgemm .transpA 1
linalg.sgemm CMmDMm CMmDMm out
saveFITS out "./${cfCMtmpdir}/CMmDM_mxp.fits"
exitCLI
EOF

# OPTIONAL
# Check orthonormality in DM space (output)
#
milk-all << EOF
linalg.sgemm .GPUdevice ${GPUdevice}
loadfits "${DMmask}" dmmask
loadfits "./${cfCMtmpdir}/CMmDMn.fits" CMmDMn
CMmDMnm=CMmDMn*dmmask
linalg.sgemm .transpA 1
linalg.sgemm CMmDMnm CMmDMnm out
saveFITS out "./${cfCMtmpdir}/CMmDMn_mxp.fits"
exitCLI
EOF

# OPTIONAL
# Reconstruct WFS from DM (TEST)

milk-all << EOF
linalg.sgemm .GPUdevice ${GPUdevice}
loadfits "./${cfCMtmpdir}/CMmDMn.fits" CMmDMn
loadfits "${zrespm}" zespM
linalg.sgemm zespM CMmDMn out
saveFITS out "./${cfCMtmpdir}/out.fits"
listim
exitCLI
EOF












########################################################################
#
# CONTROL MODES x TARGET MODES XP
#
########################################################################



# Decompose modesZFnWFSm.fits against CMmWFSn over wfsmask
# The result is stored in modesFmgsm_CMmWFSnm_xp.fits.
# The decomposition is a SGEMM over wfsmask because CMmWFSn is orthogonal
#

milk-all << EOF
linalg.sgemm .GPUdevice ${GPUdevice}
loadfits "./${cfCMtmpdir}/CMmWFSn.fits" CMmWFSn
loadfits "${WFSmask}" wfsmask
CMmWFSnm=CMmWFSn*wfsmask
loadfits "./${cfCMtmpdir}/modesZFnWFSm.fits" modesZFnWFSm
linalg.sgemm .transpA 1
linalg.sgemm modesZFnWFSm CMmWFSnm out
#linalg.sgemm CMmWFSnm modesZFnWFSm out
saveFITS out "./${cfCMtmpdir}/modesZFnWFSm_CMmWFSnm_xp.fits"
exitCLI
EOF






# Compute the rotation that will turn 
# the cross-product into a lower(0,1)/upper(2) triangular matrix, ensuring
# a good match between the two sets of modes.
# The rotation is stored as matArot.fits
# We then apply the rotation to CMmDM and CMmWFS
#
milk-all << EOF
linalg.sgemm .GPUdevice ${GPUdevice}
#loadfits "./${cfCMtmpdir}/modesFmgsm_CMmWFSnm_xp.fits" matAB
loadfits "./${cfCMtmpdir}/modesZFnWFSm_CMmWFSnm_xp.fits" matAB
linalg.basisrotmatch .optmode 0
linalg.basisrotmatch matAB matArot
# matABr.fits should now be lower triangular
saveFITS matAB "./${cfCMtmpdir}/matABr.fits"
saveFITS matArot "./${cfCMtmpdir}/matArot.fits"
#
# Apply rotation to CMmDMn
loadfits "./${cfCMtmpdir}/CMmDMn.fits" CMmDMn
#linalg.sgemm .transpB 1
linalg.sgemm CMmDMn matArot CMmDMnr
saveFITS CMmDMnr "./${cfCMtmpdir}/CMmDMnr.fits"
#
# Apply rotation to CMmWFSn
loadfits "./${cfCMtmpdir}/CMmWFSn.fits" CMmWFSn
#linalg.sgemm .transpB 1
linalg.sgemm CMmWFSn matArot CMmWFSnr
saveFITS CMmWFSnr "./${cfCMtmpdir}/CMmWFSnr.fits"
#
listim
exitCLI
EOF












# rotated basis now satisfies constraints
# check it is orthonormal


# Check original basis for reference

# OPTIONAL
milk-all << EOF
linalg.sgemm .GPUdevice ${GPUdevice}
loadfits "${WFSmask}" wfsmask
loadfits "${CMmWFS}" CMmWFS
CMmWFSm=CMmWFS*wfsmask
linalg.sgemm .transpA 1
linalg.sgemm CMmWFSm CMmWFSm out
saveFITS out "./${cfCMtmpdir}/CMmWFS_mxp.fits"
exitCLI
EOF

# OPTIONAL
milk-all << EOF
linalg.sgemm .GPUdevice ${GPUdevice}
loadfits "${DMmask}" dmmask
loadfits "${CMmDM}" CMmDM
CMmDMm=CMmDM*dmmask
linalg.sgemm .transpA 1
linalg.sgemm CMmDMm CMmDMm out
saveFITS out "./${cfCMtmpdir}/CMmDM_mxp.fits"
exitCLI
EOF



# OPTIONAL
#
# check new basis
# should be identity matrix
#
milk-all << EOF
linalg.sgemm .GPUdevice ${GPUdevice}
loadfits "${WFSmask}" wfsmask
loadfits "./${cfCMtmpdir}/CMmWFSnr.fits" CMmWFSnr
CMmWFSnrm=CMmWFSnr*wfsmask
linalg.sgemm .transpA 1
linalg.sgemm CMmWFSnrm CMmWFSnrm out
saveFITS out "./${cfCMtmpdir}/CMmWFSnr_mxp.fits"
exitCLI
EOF

# OPTIONAL
#
# should be approximately diagonal
# 
milk-all << EOF
linalg.sgemm .GPUdevice ${GPUdevice}
loadfits "${DMmask}" dmmask
loadfits "./${cfCMtmpdir}/CMmDMnr.fits" CMmDMnr
CMmDMnrm=CMmDMnr*dmmask
linalg.sgemm .transpA 1
linalg.sgemm CMmDMnrm CMmDMnrm out
saveFITS out "./${cfCMtmpdir}/CMmDMnr_mxp.fits"
exitCLI
EOF





# DM-normalize output modes
# RMS within dmmask should be = 1
#
milk-all << EOF
loadfits "./${cfCMtmpdir}/CMmWFSnr.fits" CMmWFSnr
loadfits "./${cfCMtmpdir}/CMmDMnr.fits" CMmDMnr
loadfits "${DMmask}" dmmask
normalizeslice .RMS 1
normalizeslice .auxin CMmWFSnr
normalizeslice CMmDMnr dmmask CMmDMnrn 2
listim
saveFITS CMmDMnrn "conf/CMmodesDM/CMmodesDM_sf.fits"
saveFITS CMmWFSnr "conf/CMmodesWFS/CMmodesWFS_sf.fits"
listim
exitCLI
EOF



# OPTIONAL
#
# Test that output CM DM modes are unity RMS over dmmask
# diagonal value = number pix in dmmask
# 
milk-all << EOF
linalg.sgemm .GPUdevice ${GPUdevice}
loadfits "conf/CMmodesDM/CMmodesDM_sf.fits" CMmodesDM_sf
loadfits "${DMmask}" dmmask
CMmodesDM_sfm=CMmodesDM_sf*dmmask
linalg.sgemm .transpA 1
linalg.sgemm CMmodesDM_sfm CMmodesDM_sfm out
saveFITS out "./${cfCMtmpdir}/CMmodesDM_sf_xp.fits"
exitCLI
EOF






# Spatial extrapolation of DM modes
#

milk-all << EOF
loadfits "conf/CMmodesDM/CMmodesDM_sf.fits" CMmodesDM_sf
loadfits "./${cfCMtmpdir}/modesZFnmU.fits" modesZFnmU
loadfits "./${cfCMtmpdir}/modesZFnmUe.fits" modesZFnmUe
linalg.sgemm .GPUdevice ${GPUdevice}
linalg.sgemm .transpA 1
linalg.sgemm modesZFnmU CMmodesDM_sf mcoeff
saveFITS mcoeff "./${cfCMtmpdir}/mcoeff.fits"
linalg.sgemm .transpA 0
linalg.sgemm .transpB 0
linalg.sgemm modesZFnmUe mcoeff CMmodesDM_sfme
saveFITS CMmodesDM_sfme "conf/CMmodesDM/CMmodesDM_sfme.fits"
linalg.sgemm modesZFnmU mcoeff CMmodesDM_sfmem
saveFITS CMmodesDM_sfmem "conf/CMmodesDM/CMmodesDM_sfmem.fits"
imres=CMmodesDM_sfme-CMmodesDM_sf
saveFITS imres "./${cfCMtmpdir}/imrese.fits"
loadfits "${DMmask}" dmmask
imouto=CMmodesDM_sfme*(1.0-dmmask)
listim
saveFITS imouto "./${cfCMtmpdir}/imouto.fits"
listim
exitCLI
EOF

milk-all << EOF
loadfits "conf/CMmodesDM/CMmodesDM_sf.fits" CMmodesDM_sf
loadfits "./${cfCMtmpdir}/imouto.fits" imouto
imout=CMmodesDM_sf+imouto
saveFITS imout "conf/CMmodesDM/CMmodesDM_sfe.fits"
exitCLI
EOF


errexit=0


if [ $errexit = 1 ]; then
	exit 1
fi


cacaomsglog "END"
