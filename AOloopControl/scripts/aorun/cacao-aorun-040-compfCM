#!/usr/bin/env bash

# This script uses milk-argparse
# See template milk-scriptexample in module milk_module_example for template and instructions

# temp directory for intermediate steps
cfCMtmpdir="compfCM"

# script 1-line description
MSdescr="Re-order control modes according to spatial frequency"

CMmDM="./conf/CMmodesDM/CMmodesDM.fits"
CMmWFS="./conf/CMmodesWFS/CMmodesWFS.fits"
DMmask="./conf/dmmask.fits"
WFSmask="./conf/wfsmask.fits"
zrespm="./conf/RMmodesWFS/zrespM-H.fits"

MSextdescr="Takes as input the control modes (CM) expressed in DM and WFS space
Re-orders the CM by rotations to match spatial frequency ordering.
Uses temporary directory ./${cfCMtmpdir}/

Input files read by script :
	$CMmDM
	$CMmWFS
	$DMmask
	$WFSmask
	$zrespm
"

source milk-script-std-config
source cacao-check-cacaovars


MSopt+=( "g:GPUdevice:setGPUdevice:GPUdevice[int]:Set GPU device, -1 for CPU [-1]" )
GPUdevice="-1"
function setGPUdevice()
{
	GPUdevice=$1
}

MSopt+=( "c:CPAmax:setCPAmax:cpamax[float]:Set maximum cycles per aperture (CPA) [8]" )
CPAmax="8"
function setCPAmax()
{
	CPAmax=$1
}

MSopt+=( "z:NBzer:setNBzer:NBzer[int]:Set number of Zernike polynomials [5]" )
NBzer=5
function setNBzer()
{
	NBzer=$1
}

source milk-argparse

# Re-order control modes in increasing spatial frequency by multidimentional rotation


# Input
#
# by convention:
# CMmodesWFS is orthogonal over wfsmask
# CMmodesDM is norm2 normalized over dmmask
#
#maxSVDmode=80
#CMmDM="conf/CMmodesDM/CMmodesDM.fits[*,*,1:${maxSVDmode}]"
#CMmWFS="conf/CMmodesWFS/CMmodesWFS.fits[*,*,1:${maxSVDmode}]"





mkdir -p ${cfCMtmpdir}





########################################################################
#
# TARGET MODES
#
########################################################################

# Create set of Fourier modes, store as modesF.fits
#
#CACAO_DMxsize=12
#CACAO_DMysize=12
#CACAO_DM_beam_rad=5.5
x0default=$(echo "scale=3; $CACAO_DMxsize/2-0.5" | bc)
y0default=$(echo "scale=3; $CACAO_DMysize/2-0.5" | bc)
r0default=$(echo "scale=3; 0.450*$CACAO_DMxsize" | bc)


# 2D defaults
DMsizex=${CACAO_DMxsize}
DMsizey=${CACAO_DMysize}
DMx0=${CACAO_DM_beam_xcent:-$x0default}
DMy0=${CACAO_DM_beam_ycent:-$y0default}
DMr0=${CACAO_DM_beam_rad:-$r0t}

echo "DMx0 = $DMx0"
echo "DMy0 = $DMy0"






# Create DM-space modes ordered by spatial frequency
# First modes are Zernikes, then Fourier
# Modes are not orthogonal
#
# This is the target ordering to which the new control modes should 
# match as well as possible
#
# output modesZFn.fits
#
milk-all << EOF
zern.mkzerc .radmaskfact 1.1
zern.mkzerc modesZ ${DMsizex} ${DMsizey} ${DMx0} ${DMy0} ${DMr0} ${NBzer}
saveFITS modesZ "./${cfCMtmpdir}/modesZ.fits"
lintools.mkFouriermodes .align.centered 0
lintools.mkFouriermodes .align.xcenter ${DMx0}
lintools.mkFouriermodes .align.ycenter ${DMy0}
lintools.mkFouriermodes .rCPAmin 0.1
lintools.mkFouriermodes modesF ${DMsizex} ${DMsizey} ${CPAmax} 0.8 ${DMr0} 1.2 0
saveFITS modesF "./${cfCMtmpdir}/modesF.fits"
immerge modesZ modesF modesZF 2
saveFITS modesZF "./${cfCMtmpdir}/modesZF.fits"
loadfits "${DMmask}" dmmask
modesZFm=modesZF*dmmask
normalizeslice modesZF dmmask modesZFn 2
listim
#normslice modesZFm nvec 2
#modesZFn=modesZF/nvec
saveFITS modesZFn "./${cfCMtmpdir}/modesZFn.fits"
exitCLI
EOF




# Compute WFS response of modesZFn over wfsmask -> modesZFnWFSm.fits
#
cacao << EOF
loadfits "${zrespm}" zrespM
loadfits "./${cfCMtmpdir}/modesZFn.fits" modesZFn
cacaocc.generateRMWFS zrespM modesZFn modesZFnWFS
saveFITS modesZFnWFS "./${cfCMtmpdir}/modesZFnWFS.fits"
loadfits "${WFSmask}" wfsmask
modesZFnWFSm=modesZFnWFS*wfsmask
saveFITS modesZFnWFSm "./${cfCMtmpdir}/modesZFnWFSm.fits"
exitCLI
EOF


# Gram-Schmidt -> modesFmgs
#
milk-all << EOF
loadfits "./${cfCMtmpdir}/modesZFnWFSm.fits" modesFm
linalg.GramSchmidt modesFm modesFmgs
saveFITS _outxp "./${cfCMtmpdir}/outxp.fits"
saveFITS modesFmgs "./${cfCMtmpdir}/modesFmgs.fits"
exitCLI
EOF


# OPTIONAL
# Check modesFmgs orthogonality
#
milk-all << EOF
linalg.sgemm .GPUdevice ${GPUdevice}
loadfits "./${cfCMtmpdir}/modesFmgs.fits" modesFmgs
linalg.sgemm .transpA 1
linalg.sgemm modesFmgs modesFmgs out
saveFITS out "./${cfCMtmpdir}/modesFmgsxp.fits"
exitCLI
EOF











########################################################################
#
# CONTROL MODES
#
########################################################################


# COMPUTE CONTROL MODES FROM Z-RESPM
#

# Perform PCA of zespM.fits by SVD
#
# The output is ordered by singular value
# This is not a friendly ordering, spatial frequency is not preserved
# The first modes are NOT low-order mores :(
#
milk-all << EOF
loadfits "${zrespm}" zespM
loadfits "${WFSmask}" wfsmask
zespMm=zespM*wfsmask
linalg.compSVD .GPUdevice ${GPUdevice}
linalg.compSVD .Vdim0 ${DMsizex}
linalg.compSVD zespMm mFsvdU mFsvdS mFsvdV 0.001
saveFITS SVDunmodes "./${cfCMtmpdir}/CMmWFS.fits"
saveFITS mFsvdV "./${cfCMtmpdir}/CMmDM.fits"
listim
exitCLI
EOF


# Renormalize modes in WFS space
#
# Input: 
# - CMmDM   : control modes in DM space, unity norm over dmmask
# - CMmWFS  : control modes in WFS space, orthogonal basis
# 
# Output:
# - CMmDMn  : control modes in DM space
# - CMmWFSn : control modes in WFS space, orthonormal basis over wfsmask
#
milk-all << EOF
loadfits "./${cfCMtmpdir}/CMmDM.fits" CMmDM
loadfits "./${cfCMtmpdir}/CMmWFS.fits" CMmWFS
loadfits "${WFSmask}" wfsmask
CMmWFSm=CMmWFS*wfsmask
listim
saveFITS CMmWFSm "./${cfCMtmpdir}/CMmWFSm.fits"
normslice CMmWFSm nvec 2
CMmWFSn=CMmWFS/nvec
CMmDMn=CMmDM/nvec
saveFITS nvec "./${cfCMtmpdir}/nvec.fits"
saveFITS CMmWFSn "./${cfCMtmpdir}/CMmWFSn.fits"
saveFITS CMmDMn "./${cfCMtmpdir}/CMmDMn.fits"
exitCLI
EOF


# Check orthonormality in WFS space
#
milk-all << EOF
linalg.sgemm .GPUdevice ${GPUdevice}
loadfits "${WFSmask}" wfsmask
loadfits "./${cfCMtmpdir}/CMmWFS.fits" CMmWFS
CMmWFSm=CMmWFS*wfsmask
linalg.sgemm .transpA 1
linalg.sgemm CMmWFSm CMmWFSm out
saveFITS out "./${cfCMtmpdir}/CMmWFSmxp.fits"
exitCLI
EOF

# Check orthonormality in WFS space
#
milk-all << EOF
linalg.sgemm .GPUdevice ${GPUdevice}
loadfits "${WFSmask}" wfsmask
loadfits "./${cfCMtmpdir}/CMmWFSn.fits" CMmWFSn
CMmWFSnm=CMmWFSn*wfsmask
linalg.sgemm .transpA 1
linalg.sgemm CMmWFSnm CMmWFSnm out
saveFITS out "./${cfCMtmpdir}/CMmWFSnmxp.fits"
exitCLI
EOF

# Check orthonormality in DM space
#
milk-all << EOF
linalg.sgemm .GPUdevice ${GPUdevice}
loadfits "${DMmask}" dmmask
loadfits "./${cfCMtmpdir}/CMmDM.fits" CMmDM
CMmDMm=CMmDM*dmmask
linalg.sgemm .transpA 1
linalg.sgemm CMmDMm CMmDMm out
saveFITS out "./${cfCMtmpdir}/CMmDMmxp.fits"
exitCLI
EOF


# Check orthonormality in DM space
#
milk-all << EOF
linalg.sgemm .GPUdevice ${GPUdevice}
loadfits "${DMmask}" dmmask
loadfits "./${cfCMtmpdir}/CMmDMn.fits" CMmDMn
CMmDMnm=CMmDMn*dmmask
linalg.sgemm .transpA 1
linalg.sgemm CMmDMnm CMmDMnm out
saveFITS out "./${cfCMtmpdir}/CMmDMnmxp.fits"
exitCLI
EOF

# Reconstruct WFS from DM (TEST)

milk-all << EOF
linalg.sgemm .GPUdevice ${GPUdevice}
loadfits "./${cfCMtmpdir}/CMmDMn.fits" CMmDMn
loadfits "${zrespm}" zespM
linalg.sgemm zespM CMmDMn out
saveFITS out "out.fits"
listim
exitCLI
EOF












########################################################################
#
# CONTROL MODES x TARGET MODES XP
#
########################################################################




# Decompose modesFmgs.fits against CMmWFSn over wfsmask
# The result is stored in modesFmgsm_CMmWFSnm_xp.fits.
# The decomposition is a SGEMM over wfsmask because CMmWFSn is orthogonal
#
milk-all << EOF
linalg.sgemm .GPUdevice ${GPUdevice}
loadfits "./${cfCMtmpdir}/CMmWFSn.fits" CMmWFSn
loadfits "${WFSmask}" wfsmask
CMmWFSnm=CMmWFSn*wfsmask
loadfits "./${cfCMtmpdir}/modesFmgs.fits" modesFmgs
modesFmgsm=modesFmgs*wfsmask
linalg.sgemm .transpA 1
linalg.sgemm modesFmgsm CMmWFSnm out
#linalg.sgemm CMmWFSnm modesZFnWFSm out
saveFITS out "./${cfCMtmpdir}/modesFmgsm_CMmWFSnm_xp.fits"
exitCLI
EOF







# Compute the rotation that will turn 
# the cross-product into a lower(0,1)/upper(2) triangular matrix, ensuring
# a good match between the two sets of modes.
# The rotation is stored as matArot.fits
# We then apply the rotation to CMmDM and CMmWFS
#
milk-all << EOF
linalg.sgemm .GPUdevice ${GPUdevice}
loadfits "./${cfCMtmpdir}/modesFmgsm_CMmWFSnm_xp.fits" matAB
linalg.basisrotmatch .optmode 0
linalg.basisrotmatch matAB matArot
# matABr.fits should now be lower triangular
saveFITS matAB "./${cfCMtmpdir}/matABr.fits"
saveFITS matArot "./${cfCMtmpdir}/matArot.fits"
#
# Apply rotation to CMmDMn
loadfits "./${cfCMtmpdir}/CMmDMn.fits" CMmDMn
#linalg.sgemm .transpB 1
linalg.sgemm CMmDMn matArot CMmDMnr
saveFITS CMmDMnr "./${cfCMtmpdir}/CMmDMnr.fits"
#
# Apply rotation to CMmWFSn
loadfits "./${cfCMtmpdir}/CMmWFSn.fits" CMmWFSn
#linalg.sgemm .transpB 1
linalg.sgemm CMmWFSn matArot CMmWFSnr
saveFITS CMmWFSnr "./${cfCMtmpdir}/CMmWFSnr.fits"
#
listim
exitCLI
EOF












# rotated basis now satisfies constraints
# Let's check it is orthonormal

# Check original basis for reference
milk-all << EOF
linalg.sgemm .GPUdevice ${GPUdevice}
loadfits "${WFSmask}" wfsmask
loadfits "${CMmWFS}" CMmWFS
CMmWFSm=CMmWFS*wfsmask
linalg.sgemm .transpA 1
linalg.sgemm CMmWFSm CMmWFSm out
saveFITS out "CMmWFSmxp.fits"
exitCLI
EOF

milk-all << EOF
linalg.sgemm .GPUdevice ${GPUdevice}
loadfits "${DMmask}" dmmask
loadfits "${CMmDM}" CMmDM
CMmDMm=CMmDM*dmmask
linalg.sgemm .transpA 1
linalg.sgemm CMmDMm CMmDMm out
saveFITS out "./${cfCMtmpdir}/CMmDMmxp.fits"
exitCLI
EOF




# check new basis
milk-all << EOF
linalg.sgemm .GPUdevice ${GPUdevice}
loadfits "${WFSmask}" wfsmask
loadfits "./${cfCMtmpdir}/CMmWFSnr.fits" CMmWFSnr
CMmWFSnrm=CMmWFSnr*wfsmask
linalg.sgemm .transpA 1
linalg.sgemm CMmWFSnrm CMmWFSnrm out
saveFITS out "./${cfCMtmpdir}/CMmWFSnrmxp.fits"
exitCLI
EOF

milk-all << EOF
linalg.sgemm .GPUdevice ${GPUdevice}
loadfits "${DMmask}" dmmask
loadfits "./${cfCMtmpdir}/CMmDMnr.fits" CMmDMnr
CMmDMnrm=CMmDMnr*dmmask
linalg.sgemm .transpA 1
linalg.sgemm CMmDMnrm CMmDMnrm out
saveFITS out "./${cfCMtmpdir}/CMmDMnrmxp.fits"
exitCLI
EOF





# DM-normalize output modes
# RMS within dmmask should be = 1
#
milk-all << EOF
loadfits "./${cfCMtmpdir}/CMmWFSnr.fits" CMmWFSnr
loadfits "./${cfCMtmpdir}/CMmDMnr.fits" CMmDMnr
normslice CMmDMnr nvec 2
loadfits "${DMmask}" dmmask
normslice dmmask normdmmask 2
nfact=normdmmask/nvec
CMmWFSnrn=CMmWFSnr*nfact
CMmDMnrn=CMmDMnr*nfact
CMmDMnrnm=CMmDMnrn*dmmask
saveFITS CMmWFSnrn "conf/CMmodesWFS/CMmodesWFS_sf.fits"
saveFITS CMmDMnrn "conf/CMmodesDM/CMmodesDM_sf.fits"
saveFITS CMmDMnrnm "conf/CMmodesDM/CMmodesDM_sfm.fits"
listim
exitCLI
EOF





errexit=0


if [ $errexit = 1 ]; then
	exit 1
fi


cacaomsglog "END"
