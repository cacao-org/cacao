#!/usr/bin/env bash


# exit on error
#set -o errexit

# Attempt to use undefined variable outputs error message, and forces an exit
set -o nounset


# number of arguments to script
NBARGS=1



# FATAL exit codes - causes immediate exit

# cacao task script executed outside of cacaotask environment
CACAOTASK_EXITCODE_NOTCACAOTASK=64

CACAOTASK_RUN_SUCCESS=0
CACAOTASK_RUN_FAIL=1


# Enter cacaotask environment
# Set to empty when done, or simply exit script
cacaotaskENV="OK"

cacaotask_RETURNCODE=${CACAOTASK_RUN_SUCCESS} # sucess (default)





# ======================= PROCESS NAME =================================
pnameFull=`echo "$0" | sed "s/\.\///g"`


pname=$( basename $pnameFull )

USAGESTRING="$(basename $0) [-hxXcC] <confname>"





LOOPNAME="NULL"
CURRENTDIR=$(pwd)
CONFDIR=""

QUIET=0



# colored strings
STRING_RUN_DONE="         $(tput setaf 5)$(tput bold)DONE$(tput sgr0)"
STRING_RUN_READY="        $(tput setaf 2)$(tput bold)READY$(tput sgr0)"
STRING_RUN_NOSCRIPT="     $(tput setaf 1)$(tput bold)NOSCRIPT$(tput sgr0)"
STRING_RUN_FAILED="$(tput setaf 1)$(tput bold)FAILED$(tput sgr0)->$(tput setaf 2)$(tput bold)RETRY$(tput sgr0)"
STRING_RUN_FORCE="        $(tput setaf 1)$(tput bold)FORCE$(tput sgr0)"


STRING_CLEAN_DONE="       $(tput setaf 5)$(tput bold)DONE$(tput sgr0)"
STRING_CLEAN_READY="      $(tput setaf 2)$(tput bold)READY$(tput sgr0)"
STRING_CLEAN_NOSCRIPT="   $(tput setaf 3)$(tput bold)NOSCRIPT$(tput sgr0)"
STRING_CLEAN_FAILED="     $(tput setaf 1)$(tput bold)FAILED$(tput sgr0)"
STRING_CLEAN_FORCE="      $(tput setaf 1)$(tput bold)FORCE$(tput sgr0)"



function printHELP {
    echo "------------------------------------------------------------------------"
    echo "$(tput bold) $pname : cacao task manager $(tput sgr0)"
    echo "source : $0"
    echo "------------------------------------------------------------------------"
    echo ""
    echo "Manages high-level deployment/execution tasks, such as directory setup, file downloads and script execution. Tasks are listed in a user-provided task list file, with a <TASKNAME> entry per line. Tasks can be either executed or cleaned/undone. Operation (execute or clean) are performed sequentially based on option (x/X for execute, c/C for clean) and curent completion status. Run without option to print current task completion status."
    echo ""
    echo "EXECUTE SCRIPTS"
    echo "An execute-script must exist for each task. The script must be in the system PATH, and be named: "
    echo "   cacaotask-<TASKNAME>"
    echo "The corresponding clean-script (optional) is auto-generated by the execute-script."
    echo ""
    echo "Currently available cacaotask execute-scipts on this system :"

    liststring="$( echo $PATH | tr ':' '\0' | xargs -0 ls 2> /dev/null | grep "cacaotask-" | sort )"
    filearray=($(echo $liststring | tr ";" "\n"))

    #Print the split string
    for scriptfile in "${filearray[@]}"
    do
        printf " %-30s in %s\n" "${scriptfile}" "$(which ${scriptfile})"
    done

    echo ""
    echo ""
    echo "Required user-provided files/directories :"
    echo "   <confname>-conf               [directory]   Configuration directory"
    echo "   <confname>-conf/LOOPNAME      [ASCII file]  Loop name"
    echo "   <confname>-conf/tasklist.txt  [ASCII file]  List of tasks to be executed"
    echo ""
    echo "Each task has a run-status and a clean-status."
    echo "----------  run-status ------------"
    echo "  ${STRING_RUN_DONE} : task has been successfully executed."
    echo "  ${STRING_RUN_READY} : task is ready to be executed."
    echo "  ${STRING_RUN_NOSCRIPT} : no script found for task -> Cannot be executed."
    echo "  ${STRING_RUN_FAILED} : task failed on last execution attempt. Will try again."
    echo "---------- clean-status ------------"
    echo "    ${STRING_CLEAN_DONE} : cleanup completed successfully"
    echo "    ${STRING_CLEAN_READY} : ready for task cleanup"
    echo "    ${STRING_CLEAN_NOSCRIPT} : no cleanup script exists"
    echo "    ${STRING_CLEAN_FAILED} : last cleanup failed"
    echo ""
    echo " $(tput bold)USAGE:$(tput sgr0)"
    echo "     $USAGESTRING"
    echo ""
    echo " Run without option to print current status (no action performed)"
    echo ""
    echo " $(tput bold)OPTIONS:$(tput sgr0)"
    echo "     $(tput bold)-h$(tput sgr0)            (h)elp and exit"
    echo "     $(tput bold)-x$(tput sgr0)            e(x)ecute next ready task"
    echo "     $(tput bold)-X$(tput sgr0) <step>     e(X)ecute all ready task down to and including step"
    echo "     $(tput bold)-c$(tput sgr0)            (c)clean/undo last task"
    echo "     $(tput bold)-C$(tput sgr0) <step>     (C)lean/undo all tasks up to and including step"
    echo "     $(tput bold)-f$(tput sgr0) <step>     (f)orce task to run/clean: ignore status"
    echo ""
    echo "------------------------------------------------------------------------"
}


printHELP1 ()
{
    printf "%20s       run CACAO example\n" "$0"
}


EXITSTATUS=0



function checkFile {
    if [ -f $1 ]
    then
        echo "[$(tput setaf 2)$(tput bold)   OK   $(tput sgr0)] File $(tput bold)$1$(tput sgr0) found"
    else
        echo "[$(tput setaf 1)$(tput bold) FAILED $(tput sgr0)] File $(tput bold)$1$(tput sgr0) not found"
        EXITSTATUS=1
    fi
}


function checkFileCreate {
    if [ -f $1 ]
    then
        echo "[$(tput setaf 2)$(tput bold)   OK   $(tput sgr0)] File $(tput bold)$1$(tput sgr0) found"
    else
        echo "[$(tput setaf 3)$(tput bold)  INFO  $(tput sgr0)] File $(tput bold)$1$(tput sgr0) not found: Creating"
        touch $1
    fi
}

function checkFileInfoOptional {
    if [ -f $1 ]
    then
        echo "[$(tput setaf 2)$(tput bold)   OK   $(tput sgr0)] File $(tput bold)$1$(tput sgr0) found"
    else
        echo "[$(tput setaf 3)$(tput bold)  INFO  $(tput sgr0)] Optional file $(tput bold)$1$(tput sgr0) not found"
    fi
}


function checkDir {
    if [ -d $1 ]
    then
        echo "[$(tput setaf 2)$(tput bold)   OK   $(tput sgr0)] Directory $(tput bold)$1$(tput sgr0) found"
    else
        echo "[$(tput setaf 1)$(tput bold) FAILED $(tput sgr0)] Directory $(tput bold)$1$(tput sgr0) not found"
        EXITSTATUS=1
    fi
}


function cmdexists()
{
    command -v "$1" >/dev/null 2>&1
}


function checkCommand {
    if cmdexists $1; then
        if [ ${QUIET} = 0 ]; then
            echo "[$(tput setaf 2)$(tput bold)   OK   $(tput sgr0)] Command $(tput bold)$1$(tput sgr0) found"
        fi
        COMMAND_FOUND=1
    else
        if [ ${QUIET} = 0 ]; then
            echo "[$(tput setaf 1)$(tput bold) FAILED $(tput sgr0)] Command $(tput bold)$1$(tput sgr0) not installed.  Aborting."
        fi
        COMMAND_FOUND=0
        EXITSTATUS=1;
    fi
}











# ================= OPTIONS =============================
# Transform long options to short ones
singlelinehelp=0
for arg in "$@"; do
    shift
    case "$arg" in
        "--help") set -- "$@" "-h" ;;
        "--help1")
            set -- "$@" "-h"
            singlelinehelp=1;
            ;;
        *)        set -- "$@" "$arg"
    esac
done


CLEANMODE=0
EXECMODE=0

SINGLETASK=0
FORCE=0
FORCEINDEX=0
LASTTASK=1000


while getopts :hxX:cC:f: FLAG; do
    case $FLAG in
        h)  #show help
            if [ "$singlelinehelp" -eq "0" ]; then
                printHELP
            else
                printHELP1
            fi
            exit
            ;;
        x) # run next task
            EXECMODE=1
            SINGLETASK=1
            LASTTASK=1000
            ;;
        X) # run all tasks
            EXECMODE=1
            LASTTASK=${OPTARG}
            ;;
        c) # clean single task
            CLEANMODE=1
            SINGLETASK=1
            LASTTASK=0
            ;;
        C) # clean all tasks
            CLEANMODE=1
            LASTTASK=${OPTARG}
            ;;
        f)
            FORCE=1
            FORCEINDEX=${OPTARG}
            ;;
        \?) #unrecognized option - show help
            echo -e \\n"Option $OPTARG not allowed."
            printHELP
            ;;
    esac
done
shift $((OPTIND-1))




if [ "$#" -ne $NBARGS ]; then
    echo "$(tput setaf 1)$(tput bold) Illegal number of parameters ($NBARGS params required, $# entered) $(tput sgr0)"
    echo "Usage :"
    echo "  $USAGESTRING"
    echo ""
    exit
fi



echo ""
echo "Checking required commands :"
checkCommand xterm
checkCommand tmux


echo ""
echo "Checking required files :"

CONFNAME="$1"

CONFDIR="${CURRENTDIR}/${CONFNAME}-conf"
checkDir ${CONFDIR}


LOOPNAMEFILE="${CONFDIR}/LOOPNAME"
checkFile ${LOOPNAMEFILE}
if [ -f $LOOPNAMEFILE ]; then
    LOOPNAME="$(cat $LOOPNAMEFILE)"
fi


TASKLISTFILE="${CONFDIR}/tasklist.txt"
checkFile ${TASKLISTFILE}


CACAOVARSFILE="${CONFDIR}/cacaovars.bash"
checkFile ${CACAOVARSFILE}
source ${CACAOVARSFILE}

FPSSETUPFILE="${CONFDIR}/fpssetup.setval.conf"
checkFile ${FPSSETUPFILE}



if [ $EXITSTATUS = 1 ]; then
    exit
fi



# log directory
# keeps track of what has been executed
#
LOGDIR="${CURRENTDIR}/.${LOOPNAME}-cacaotaskmanager-log"
mkdir -p $LOGDIR












# Execute task
#
function task_EXEC {
    LOGRUNFILE="${LOGDIR}/task.${TASKCODE}.RUN"

    ENVOUTFILE="${LOGDIR}/task.${TASKCODE}.ENVOUT.bash"
    touch ${ENVOUTFILE}

    CLEANSCRIPT="${LOGDIR}/task.${TASKCODE}.CLEAN.bash"
    echo "#!/bin/bash" > ${CLEANSCRIPT}
    chmod a+x ${CLEANSCRIPT}
    sleep 0.1

    source ${EXECfile}

    if [ ${cacaotask_RETURNCODE} = ${CACAOTASK_RUN_SUCCESS} ]; then
        # success
        touch "${LOGDIR}/task.${TASKCODE}.RUN.DONE"
    else
        # failure
        echo "${CACAOTASK_RUN_SUCCESS}" > "${LOGDIR}/task.${TASKCODE}.RUN.FAILED"
    fi

    mv -f ${LOGDIR}/task.${TASKCODE}.CLEAN.DONE ${LOGDIR}/task.${TASKCODE}.CLEAN.DONE.arch &> /dev/null
    mv -f ${LOGDIR}/task.${TASKCODE}.CLEAN.FAILED ${LOGDIR}/task.${TASKCODE}.CLEAN.FAILED.arch &> /dev/null
}


function task_SKIP {
    ENVOUTFILE="${LOGDIR}/task.${TASKCODE}.ENVOUT.bash"
    source ${ENVOUTFILE}
}


function task_CLEAN {
    LOGCLEANFILE="${LOGDIR}/task.${TASKCODE}.CLEAN"
    #CLEANTASK="NULL"

    source ${LOGDIR}/task.${TASKCODE}.CLEAN.bash

    rm ${LOGDIR}/task.${TASKCODE}.RUN.DONE &> /dev/null
    rm ${LOGDIR}/task.${TASKCODE}.RUN.FAILED &> /dev/null

    # success
    touch ${LOGDIR}/task.${TASKCODE}.CLEAN.DONE

    # failure
    #touch "${LOGDIR}/task.${TASKCODE}.CLEAN.FAILED"
}





#
# READ TASK(S) TO BE EXECUTED FROM FILE
#

TASKCODEARRAY=( )
TASKDESCRARRAY=( )

function join { local IFS=" "; shift; echo "$*"; }


readarray -t TASKARRAY < ${TASKLISTFILE}

for taskarrayline in "${TASKARRAY[@]}";do
    taskline=(${taskarrayline}:)
    if [ ${#taskline} -gt 1 ]; then
        if [ ${taskline:0:1} != "#" ]; then
            TASKCODEARRAY+=( "${taskline[0]}" )
            TASKDESCRARRAY+=( "$(join ${taskline[@]})" )
        fi
    fi
done






echo ""
echo " CONFIGURATION : ${CONFNAME}"
echo ""
echo "    LOOPNAME           : $LOOPNAME"
echo "    CURRENTDIR         : $CURRENTDIR"
echo "    CONFDIR            : $CONFDIR"
echo "    LOGDIR             : $LOGDIR"
echo ""


# temporarly disable exit-on-error
set +o nounset
if [[ -z "${CACAO_LOOPROOTDIR}" ]]; then
    CACAO_LOOPROOTDIR="${LOOPNAME}-rootdir"
    echo "CACAO_LOOPROOTDIR    not set -> using default : ${CACAO_LOOPROOTDIR}"
else
    echo "CACAO_LOOPROOTDIR    : ${CACAO_LOOPROOTDIR}"
fi
# Attempt to use undefined variable outputs error message, and forces an exit
set -o nounset




function READ_STATUS {

    QUIET=1

    RUNSTATUSARRAY=( )
    CLEANSTATUSARRAY=( )

    #
    # READ STATUS
    #
    tindex=0
    for TASKCODE in ${TASKCODEARRAY[@]}; do
        # RUN
        #	DONE     : task has been executed
        #	READY    : task has not yet been executed
        #   NOSCRIPT : task run script is missing
        #   FAILED   : task has failed
        #
        # RUN file exists ?
        #
        RUNSCRIPT="cacaotask-${TASKCODE}"
        STATUS="???"
        checkCommand ${RUNSCRIPT}
        #if [ ! -f ${RUNSCRIPT} ]; then
        if [ ${COMMAND_FOUND} = 0 ]; then
            STATUS="NOSCRIPT"
            echo "$(tput setaf 1)$(tput bold) ERROR NOSCRIPT $(tput sgr0)cannot find script ${RUNSCRIPT}. Ensure it is in PATH"
        else
            STATUS="READY"  # default

            RUNLOGFILE="${LOGDIR}/task.${TASKCODE}.RUN.DONE"
            if [ -f ${RUNLOGFILE} ]; then
                STATUS="DONE"
            fi

            RUNLOGFILE="${LOGDIR}/task.${TASKCODE}.RUN.FAILED"
            if [ -f ${RUNLOGFILE} ]; then
                STATUS="FAILED"
            fi

            if [ ${FORCE} = 1 ]; then
                if [ "${STATUS}" != "READY" ]; then
                    if [ ${tindex} = ${FORCEINDEX} ]; then
                        STATUS="FORCE"
                    fi
                fi
            fi
        fi
        RUNSTATUSARRAY+=( "${STATUS}" )

        # CLEAN
        #   DONE     : clean done
        #	READY    : ready for cleanup (script exists)
        #   NOSCRIPT : script does not exist
        #   FAILED   : clean failed
        #
        # clean script exists ?
        #
        CLEANSCRIPT="${LOGDIR}/task.${TASKCODE}.CLEAN.bash"
        STATUS="???"
        if [ ! -f ${CLEANSCRIPT} ]; then
            STATUS="NOSCRIPT"
        else
            STATUS="READY"  # default

            CLEANLOGFILE="${LOGDIR}/task.${TASKCODE}.CLEAN.DONE"
            if [ -f ${CLEANLOGFILE} ]; then
                STATUS="DONE"
            fi

            CLEANLOGFILE="${LOGDIR}/task.${TASKCODE}.CLEAN.FAILED"
            if [ -f ${CLEANLOGFILE} ]; then
                STATUS="FAILED"
            fi

            if [ ${FORCE} = 1 ]; then
                if [ "${STATUS}" != "READY" ]; then
                    if [ ${tindex} = ${FORCEINDEX} ]; then
                        STATUS="FORCE"
                    fi
                fi
            fi
        fi
        CLEANSTATUSARRAY+=( "${STATUS}" )
        let tindex+=1
    done
}



#
# print current status
#




function PRINT_STATUS {
    echo ""
    printf "    %18s    %12s  %12s\n" "TASK" "RUN STATUS" "CLEAN STATUS"
    echo "----------------------------------------------------------"
    for i in ${!TASKCODEARRAY[@]};
    do
        TASKCODE="${TASKCODEARRAY[$i]}"
        CLEANSTAT="${CLEANSTATUSARRAY[$i]}"

        RUNSTAT="${RUNSTATUSARRAY[$i]}"
        RUNSTATSTRING="${RUNSTAT}"
        if [ "${RUNSTAT}" = "DONE" ]; then
            RUNSTATSTRING="${STRING_RUN_DONE}"
        fi
        if [ "${RUNSTAT}" = "READY" ]; then
            RUNSTATSTRING="${STRING_RUN_READY}"
        fi
        if [ "${RUNSTAT}" = "NOSCRIPT" ]; then
            RUNSTATSTRING="${STRING_RUN_NOSCRIPT}"
        fi
        if [ "${RUNSTAT}" = "FAILED" ]; then
            RUNSTATSTRING="${STRING_RUN_FAILED}"
        fi
        if [ "${RUNSTAT}" = "FORCE" ]; then
            RUNSTATSTRING="${STRING_RUN_FORCE}"
        fi


        CLEANSTAT="${CLEANSTATUSARRAY[$i]}"
        CLEANSTATSTRING="${CLEANSTAT}"
        if [ "${CLEANSTAT}" = "DONE" ]; then
            CLEANSTATSTRING="${STRING_CLEAN_DONE}"
        fi
        if [ "${CLEANSTAT}" = "READY" ]; then
            CLEANSTATSTRING="${STRING_CLEAN_READY}"
        fi
        if [ "${CLEANSTAT}" = "NOSCRIPT" ]; then
            CLEANSTATSTRING="${STRING_CLEAN_NOSCRIPT}"
        fi
        if [ "${CLEANSTAT}" = "FAILED" ]; then
            CLEANSTATSTRING="${STRING_CLEAN_FAILED}"
        fi
        if [ "${CLEANSTAT}" = "FORCE" ]; then
            CLEANSTATSTRING="${STRING_CLEAN_FORCE}"
        fi

        printf "%2d  %18s    %8s  %8s   ${TASKDESCRARRAY[$i]}\n" "${i}" "${TASKCODE}" "${RUNSTATSTRING}" "${CLEANSTATSTRING}"
    done
}








READ_STATUS
PRINT_STATUS


NBTASKDONE=0

echo ""
#
# EXECUTE TASKS
#
let TASKINDEX=0
for i in ${!TASKCODEARRAY[@]};
do
    TASKCODE="${TASKCODEARRAY[$i]}"

    if [ "${TASKINDEX}" -gt "${LASTTASK}" ]; then
        EXECMODE=0
    fi

    if [ ${EXECMODE} = 1 ]; then
        if [ "${RUNSTATUSARRAY[$i]}" = "DONE" ]; then
            ENVOUTFILE="${LOGDIR}/task.${TASKCODE}.ENVOUT.bash"
            printf "%s %20s  sourcing %s\n"  "   $(tput bold)SKIP$(tput sgr0)" "$TASKCODE" "${ENVOUTFILE} "
            task_SKIP
        fi

        if [ "${RUNSTATUSARRAY[$i]}" = "READY" ] || [ "${RUNSTATUSARRAY[$i]}" = "FAILED" ]|| [ "${RUNSTATUSARRAY[$i]}" = "FORCE" ]; then
            EXECfile=$( which cacaotask-${TASKCODE} )
            printf "%s %20s  executing %s\n"  "$(tput rev)EXECUTE$(tput sgr0)" "$TASKCODE" "${EXECfile} "
            task_EXEC
            let NBTASKDONE+=1
            if [ ${SINGLETASK} = 1 ]; then
                EXECMODE=0
            fi
        fi

    fi
    let TASKINDEX+=1
done


#
# CLEAN TASKS
#
# scan backward for cleanup
let TASKINDEX-=1
until [  ${TASKINDEX} -lt 0 ]; do
    TASKCODE="${TASKCODEARRAY[${TASKINDEX}]}"

    if [ "${TASKINDEX}" -lt "${LASTTASK}" ]; then
        CLEANMODE=0
    fi

    if [ ${CLEANMODE} = 1 ]; then
        if [ "${CLEANSTATUSARRAY[${TASKINDEX}]}" = "READY" ] || [ "${CLEANSTATUSARRAY[${TASKINDEX}]}" = "FORCE" ]; then
            echo "    $(tput rev)CLEAN$(tput sgr0)    $TASKCODE"
            task_CLEAN
            let NBTASKDONE+=1
            if [ ${SINGLETASK} = 1 ]; then
                CLEANMODE=0
            fi
        fi
    fi
    let TASKINDEX-=1
done



if [ ${NBTASKDONE} = 0 ]; then
    echo "No task performed"
else
    echo "${NBTASKDONE} task(s) performed"
    sync

    READ_STATUS
    PRINT_STATUS
fi
