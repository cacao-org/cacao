#!/usr/bin/env bash

# ======================= PROCESS NAME =================================
pnameFull=`echo "$0" | sed "s/\.\///g"`
pname=$( basename $pnameFull )

MSdescr="Manage cacao deployment tasts"

source milk-script-std-config




# colored strings
STRING_RUN_DONE="         $(tput setaf 5)$(tput bold)DONE$(tput sgr0)"
STRING_RUN_READY="        $(tput setaf 2)$(tput bold)READY$(tput sgr0)"
STRING_RUN_NOSCRIPT="     $(tput setaf 1)$(tput bold)NOSCRIPT$(tput sgr0)"
STRING_RUN_FAILED="$(tput setaf 1)$(tput bold)FAILED$(tput sgr0)->$(tput setaf 2)$(tput bold)RETRY$(tput sgr0)"
STRING_RUN_FORCE="        $(tput setaf 1)$(tput bold)FORCE$(tput sgr0)"


STRING_CLEAN_DONE="       $(tput setaf 5)$(tput bold)DONE$(tput sgr0)"
STRING_CLEAN_READY="      $(tput setaf 2)$(tput bold)READY$(tput sgr0)"
STRING_CLEAN_NOSCRIPT="   $(tput setaf 3)$(tput bold)NOSCRIPT$(tput sgr0)"
STRING_CLEAN_FAILED="     $(tput setaf 1)$(tput bold)FAILED$(tput sgr0)"
STRING_CLEAN_FORCE="      $(tput setaf 1)$(tput bold)FORCE$(tput sgr0)"


CMDTASKLIST=$(compgen -c "cacaotask-" | sort -u )
IFS=$'\r\n' GLOBIGNORE='*' command eval  'taskarray=($CMDTASKLIST)'
taskliststring="\n"
for scriptfile in "${taskarray[@]}"
do
	taskliststring+=$(printf " %-30s in %s\n" "${scriptfile}" "$(which ${scriptfile})")
	taskliststring+="\n"
done
    
    
MSextdescr="
Manages high-level deployment/execution tasks, such as directory setup, file downloads and script execution. Tasks are listed in a user-provided task list file, with a <TASKNAME> entry per line. Tasks can be either executed or cleaned/undone. Operation (execute or clean) are performed sequentially based on option (x/X for execute, c/C for clean) and curent completion status. Run without option to print current task completion status.

EXECUTE SCRIPTS
An execute-script must exist for each task. The script must be in the system PATH, and be named: 
   cacaotask-<TASKNAME>
The corresponding clean-script (optional) is auto-generated by the execute-script.

Currently available cacaotask execute-scipts on this system :
${taskliststring}

Required user-provided files/directories :
   <confname>-conf               [directory]   Configuration directory
   <confname>-conf/tasklist.txt  [ASCII file]  List of tasks to be executed

Each task has a run-status and a clean-status.
----------  run-status ------------
  ${STRING_RUN_DONE} : task has been successfully executed.
  ${STRING_RUN_READY} : task is ready to be executed.
  ${STRING_RUN_NOSCRIPT} : no script found for task -> Cannot be executed.
  ${STRING_RUN_FAILED} : task failed on last execution attempt. Will try again.
---------- clean-status ------------
    ${STRING_CLEAN_DONE} : cleanup completed successfully
    ${STRING_CLEAN_READY} : ready for task cleanup
    ${STRING_CLEAN_NOSCRIPT} : no cleanup script exists
    ${STRING_CLEAN_FAILED} : last cleanup failed

Run without option to print current status (no action performed)
"


# prerequisites
#
RequiredCommands=( tmux )
RequiredFiles=()
RequiredDirs=()


MSarg+=( "confname:string:configuration name" )



CLEANMODE=0
EXECMODE=0

SINGLETASK=0
FORCE=0
FORCEINDEX=0
LASTTASK=1000

MSopt+=( "x:exntask:set_execute_next_task::e(x)ecute next ready task" )
function set_execute_next_task() {
	EXECMODE=1
	SINGLETASK=1
	LASTTASK=1000
}

MSopt+=( "X:exatask:set_execute_all_task:lasttask[int]:e(X)ecute all ready task down to and including step" )
function set_execute_all_task() {
	EXECMODE=1
	LASTTASK=$1
}

MSopt+=( "c:clean:set_clean_last_task::(c)clean/undo last task" )
function set_clean_last_task() {
	CLEANMODE=1
	SINGLETASK=1
	LASTTASK=0
}

MSopt+=( "C:Clean:set_clean_all_task:taskstep[int]:(C)lean/undo all tasks up to and including step" )
function set_clean_all_task() {
	CLEANMODE=1
	LASTTASK=$1
}

MSopt+=( "f:force:set_force:taskstep[int]:(f)orce task to run/clean: ignore status" )
function set_force() {
	FORCE=1
	FORCEINDEX=$1
}






source milk-argparse

CONFNAME="${inputMSargARRAY[0]}"


echo "SINGLETASK   : ${SINGLETASK}"
echo "EXECMODE     : ${EXECMODE}"
echo "LASTTASK     : ${LASTTASK}"


# cacao task script executed outside of cacaotask environment
CACAOTASK_EXITCODE_NOTCACAOTASK=64
CACAOTASK_RUN_SUCCESS=0
CACAOTASK_RUN_FAIL=1


# Enter cacaotask environment
# Set to empty when done, or simply exit script
cacaotaskENV="OK"

cacaotask_RETURNCODE=${CACAOTASK_RUN_SUCCESS} # sucess (default)



CURRENTDIR=$(pwd)

QUIET=0

CONFDIR="${CURRENTDIR}/${CONFNAME}-conf"
checkDir ${CONFDIR}

TASKLISTFILE="${CONFDIR}/tasklist.txt"
checkFile ${TASKLISTFILE}

CACAOVARSFILE="${CONFDIR}/cacaovars.bash"
checkFile ${CACAOVARSFILE}
source ${CACAOVARSFILE}

FPSSETUPFILE="${CONFDIR}/fpssetup.setval.conf"
checkFile ${FPSSETUPFILE}


if [ $EXITSTATUS = 1 ]; then
    exit 1
fi





# log directory
# keeps track of what has been executed
#
LOGDIR="${CURRENTDIR}/.${CACAO_LOOPNAME}.cacaotaskmanager-log"
mkdir -p $LOGDIR






# Execute task
#
function task_EXEC {
    LOGRUNFILE="${LOGDIR}/task.${CACAO_LOOPNAME}.${TASKCODE}.RUN"

    ENVOUTFILE="${LOGDIR}/task.${CACAO_LOOPNAME}.${TASKCODE}.ENVOUT.bash"
    touch ${ENVOUTFILE}
	

    CLEANSCRIPT="${LOGDIR}/task.${CACAO_LOOPNAME}.${TASKCODE}.CLEAN.bash"
    echo "#!/bin/bash" > ${CLEANSCRIPT}
    chmod a+x ${CLEANSCRIPT}
    sleep 0.1

	echo "Sourcing ${EXECfile}"
    source ${EXECfile}

    if [ ${cacaotask_RETURNCODE} = ${CACAOTASK_RUN_SUCCESS} ]; then
        # success
        touch "${LOGDIR}/task.${CACAO_LOOPNAME}.${TASKCODE}.RUN.DONE"
    else
        # failure
        echo "${CACAOTASK_RUN_SUCCESS}" > "${LOGDIR}/task.${CACAO_LOOPNAME}.${TASKCODE}.RUN.FAILED"
    fi

    mv -f ${LOGDIR}/task.${CACAO_LOOPNAME}.${TASKCODE}.CLEAN.DONE ${LOGDIR}/task.${CACAO_LOOPNAME}.${TASKCODE}.CLEAN.DONE.arch &> /dev/null || :
    mv -f ${LOGDIR}/task.${CACAO_LOOPNAME}.${TASKCODE}.CLEAN.FAILED ${LOGDIR}/task.${CACAO_LOOPNAME}.${TASKCODE}.CLEAN.FAILED.arch &> /dev/null || :
}


function task_SKIP {
    ENVOUTFILE="${LOGDIR}/task.${CACAO_LOOPNAME}.${TASKCODE}.ENVOUT.bash"
    source ${ENVOUTFILE}
}


function task_CLEAN {
    LOGCLEANFILE="${LOGDIR}/task.${CACAO_LOOPNAME}.${TASKCODE}.CLEAN"
    #CLEANTASK="NULL"

    source ${LOGDIR}/task.${CACAO_LOOPNAME}.${TASKCODE}.CLEAN.bash

    rm -f ${LOGDIR}/task.${CACAO_LOOPNAME}.${TASKCODE}.RUN.DONE &> /dev/null || :
    rm -f ${LOGDIR}/task.${CACAO_LOOPNAME}.${TASKCODE}.RUN.FAILED &> /dev/null || :

    # success
    touch ${LOGDIR}/task.${CACAO_LOOPNAME}.${TASKCODE}.CLEAN.DONE

    # failure
    #touch "${LOGDIR}/task.${CACAO_LOOPNAME}.${TASKCODE}.CLEAN.FAILED"
}





#
# READ TASK(S) TO BE EXECUTED FROM FILE
#

TASKCODEARRAY=( )
TASKDESCRARRAY=( )

function join { local IFS=" "; shift; echo "$*"; }


echo "TASKLISTFILE  :  ${TASKLISTFILE}"
readarray -t TASKARRAY < ${TASKLISTFILE}

for taskarrayline in "${TASKARRAY[@]}";do
    taskline=(${taskarrayline}:)
    if [ ${#taskline} -gt 1 ]; then
        if [ ${taskline:0:1} != "#" ]; then
            TASKCODEARRAY+=( "${taskline[0]}" )
            TASKDESCRARRAY+=( "$(join ${taskline[@]})" )
        fi
    fi
done

echo "TASKCODEARRAY = ${TASKCODEARRAY}"




echo ""
echo " CONFIGURATION : ${CONFNAME}"
echo ""
echo "    LOOPNAME           : $CACAO_LOOPNAME"
echo "    LOOPROOTDIR        : ${CACAO_LOOPROOTDIR}"
echo "    LOOPRUNDIR         : ${CACAO_LOOPRUNDIR}"
echo "    CURRENTDIR         : $CURRENTDIR"
echo "    CONFDIR            : $CONFDIR"
echo "    LOGDIR             : $LOGDIR"
echo ""






function READ_STATUS {

    QUIET=1

    RUNSTATUSARRAY=( )
    CLEANSTATUSARRAY=( )

    #
    # READ STATUS
    #
    tindex=0
    for TASKCODE in ${TASKCODEARRAY[@]}; do
        # RUN
        #	DONE     : task has been executed
        #	READY    : task has not yet been executed
        #   NOSCRIPT : task run script is missing
        #   FAILED   : task has failed
        #
        # RUN file exists ?
        #
        RUNSCRIPT="cacaotask-${TASKCODE}"
        STATUS="???"
        checkCommand ${RUNSCRIPT}
        #if [ ! -f ${RUNSCRIPT} ]; then
        if [ ${COMMAND_FOUND} = 0 ]; then
            STATUS="NOSCRIPT"
            echo "$(tput setaf 1)$(tput bold) ERROR NOSCRIPT $(tput sgr0)cannot find script ${RUNSCRIPT}. Ensure it is in PATH"
        else
            STATUS="READY"  # default

            RUNLOGFILE="${LOGDIR}/task.${CACAO_LOOPNAME}.${TASKCODE}.RUN.DONE"
            if [ -f ${RUNLOGFILE} ]; then
                STATUS="DONE"
            fi

            RUNLOGFILE="${LOGDIR}/task.${CACAO_LOOPNAME}.${TASKCODE}.RUN.FAILED"
            if [ -f ${RUNLOGFILE} ]; then
                STATUS="FAILED"
            fi

            if [ ${FORCE} = 1 ]; then
                if [ "${STATUS}" != "READY" ]; then
                    if [ ${tindex} = ${FORCEINDEX} ]; then
                        STATUS="FORCE"
                    fi
                fi
            fi
        fi
        RUNSTATUSARRAY+=( "${STATUS}" )

        # CLEAN
        #   DONE     : clean done
        #	READY    : ready for cleanup (script exists)
        #   NOSCRIPT : script does not exist
        #   FAILED   : clean failed
        #
        # clean script exists ?
        #
        CLEANSCRIPT="${LOGDIR}/task.${CACAO_LOOPNAME}.${TASKCODE}.CLEAN.bash"
        STATUS="???"
        if [ ! -f ${CLEANSCRIPT} ]; then
            STATUS="NOSCRIPT"
        else
            STATUS="READY"  # default

            CLEANLOGFILE="${LOGDIR}/task.${CACAO_LOOPNAME}.${TASKCODE}.CLEAN.DONE"
            if [ -f ${CLEANLOGFILE} ]; then
                STATUS="DONE"
            fi

            CLEANLOGFILE="${LOGDIR}/task.${CACAO_LOOPNAME}.${TASKCODE}.CLEAN.FAILED"
            if [ -f ${CLEANLOGFILE} ]; then
                STATUS="FAILED"
            fi

            if [ ${FORCE} = 1 ]; then
                if [ "${STATUS}" != "READY" ]; then
                    if [ ${tindex} = ${FORCEINDEX} ]; then
                        STATUS="FORCE"
                    fi
                fi
            fi
        fi
        CLEANSTATUSARRAY+=( "${STATUS}" )
        let tindex+=1 || :
    done
}



#
# print current status
#




function PRINT_STATUS {
    echo ""
    printf "    %18s    %12s  %12s\n" "TASK" "RUN STATUS" "CLEAN STATUS"
    echo "----------------------------------------------------------"
    for i in ${!TASKCODEARRAY[@]};
    do
        TASKCODE="${TASKCODEARRAY[$i]}"
        CLEANSTAT="${CLEANSTATUSARRAY[$i]}"
        
        RUNSTAT="${RUNSTATUSARRAY[$i]}"
        RUNSTATSTRING="${RUNSTAT}"
        if [ "${RUNSTAT}" = "DONE" ]; then
            RUNSTATSTRING="${STRING_RUN_DONE}"
        fi
        if [ "${RUNSTAT}" = "READY" ]; then
            RUNSTATSTRING="${STRING_RUN_READY}"
        fi
        if [ "${RUNSTAT}" = "NOSCRIPT" ]; then
            RUNSTATSTRING="${STRING_RUN_NOSCRIPT}"
        fi
        if [ "${RUNSTAT}" = "FAILED" ]; then
            RUNSTATSTRING="${STRING_RUN_FAILED}"
        fi
        if [ "${RUNSTAT}" = "FORCE" ]; then
            RUNSTATSTRING="${STRING_RUN_FORCE}"
        fi


        CLEANSTAT="${CLEANSTATUSARRAY[$i]}"
        CLEANSTATSTRING="${CLEANSTAT}"
        if [ "${CLEANSTAT}" = "DONE" ]; then
            CLEANSTATSTRING="${STRING_CLEAN_DONE}"
        fi
        if [ "${CLEANSTAT}" = "READY" ]; then
            CLEANSTATSTRING="${STRING_CLEAN_READY}"
        fi
        if [ "${CLEANSTAT}" = "NOSCRIPT" ]; then
            CLEANSTATSTRING="${STRING_CLEAN_NOSCRIPT}"
        fi
        if [ "${CLEANSTAT}" = "FAILED" ]; then
            CLEANSTATSTRING="${STRING_CLEAN_FAILED}"
        fi
        if [ "${CLEANSTAT}" = "FORCE" ]; then
            CLEANSTATSTRING="${STRING_CLEAN_FORCE}"
        fi

        printf "%2d  %18s    %8s  %8s   ${TASKDESCRARRAY[$i]}\n" "${i}" "${TASKCODE}" "${RUNSTATSTRING}" "${CLEANSTATSTRING}"
    done
}








READ_STATUS
PRINT_STATUS


NBTASKDONE=0



#
# EXECUTE TASKS
#
TASKINDEX=0

for i in ${!TASKCODEARRAY[@]};
do
    TASKCODE="${TASKCODEARRAY[$i]}"
    
    if [ "${TASKINDEX}" -gt "${LASTTASK}" ]; then
        EXECMODE=0
    fi

    if [ ${EXECMODE} = 1 ]; then
        if [ "${RUNSTATUSARRAY[$i]}" = "DONE" ]; then
            ENVOUTFILE="${LOGDIR}/task.${CACAO_LOOPNAME}.${TASKCODE}.ENVOUT.bash"
            printf "%s %20s  sourcing %s\n"  "   $(tput bold)SKIP$(tput sgr0)" "$TASKCODE" "${ENVOUTFILE} "
            task_SKIP
        fi

        if [ "${RUNSTATUSARRAY[$i]}" = "READY" ] || [ "${RUNSTATUSARRAY[$i]}" = "FAILED" ]|| [ "${RUNSTATUSARRAY[$i]}" = "FORCE" ]; then
            EXECfile=$( which cacaotask-${TASKCODE} )
            printf "%s %20s  executing %s\n"  "$(tput rev)EXECUTE$(tput sgr0)" "$TASKCODE" "${EXECfile} "
            task_EXEC
            let NBTASKDONE+=1 || :
            if [ ${SINGLETASK} = 1 ]; then
                EXECMODE=0
            fi
        fi

    fi
    let TASKINDEX+=1 || :
done


#
# CLEAN TASKS
#
# scan backward for cleanup
let TASKINDEX-=1 || :

until [  ${TASKINDEX} -lt 0 ]; do
    TASKCODE="${TASKCODEARRAY[${TASKINDEX}]}"

    if [ "${TASKINDEX}" -lt "${LASTTASK}" ]; then
        CLEANMODE=0
    fi
    if [ ${CLEANMODE} = 1 ]; then
        if [ "${CLEANSTATUSARRAY[${TASKINDEX}]}" = "READY" ] || [ "${CLEANSTATUSARRAY[${TASKINDEX}]}" = "FORCE" ]; then
            echo "    $(tput rev)CLEAN$(tput sgr0)    $TASKCODE"
            task_CLEAN
            let NBTASKDONE+=1 || :
            if [ ${SINGLETASK} = 1 ]; then
                CLEANMODE=0
            fi
        fi
    fi
    let TASKINDEX-=1 || :
done



if [ ${NBTASKDONE} = 0 ]; then
    echo "No task performed"
else
    echo "${NBTASKDONE} task(s) performed"
    sync

    READ_STATUS
    PRINT_STATUS
fi




