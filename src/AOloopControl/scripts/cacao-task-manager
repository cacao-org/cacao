#!/bin/bash



# exit on error
#set -o errexit

# Attempt to use undefined variable outputs error message, and forces an exit
set -o nounset


# number of arguments to script
NBARGS=1



# FATAL exit codes - causes immediate exit

# cacao task script executed outside of cacaotask environment
CACAOTASK_EXITCODE_NOTCACAOTASK=64

CACAOTASK_RUN_SUCCESS=0
CACAOTASK_RUN_FAIL=1


# Enter cacaotask environment
# Set to empty when done, or simply exit script
cacaotaskENV="OK"

cacaotask_RETURNCODE=${CACAOTASK_RUN_SUCCESS} # sucess (default)





# ======================= PROCESS NAME =================================
pnameFull=`echo "$0" | sed "s/\.\///g"`


pname=$( basename $pnameFull )

USAGESTRING="$(basename $0) [-hxXcC] <confname>"





LOOPNAME="NULL"
CURRENTDIR=$(pwd)
CONFDIR=""
WORKDIRECTORY=""
WORKDIRECTORYLOCAL=""

QUIET=0



# colored strings
STRING_RUN_DONE="         $(tput setaf 5)$(tput bold)DONE$(tput sgr0)"
STRING_RUN_READY="        $(tput setaf 2)$(tput bold)READY$(tput sgr0)"
STRING_RUN_NOSCRIPT="     $(tput setaf 1)$(tput bold)NOSCRIPT$(tput sgr0)"
STRING_RUN_FAILED="$(tput setaf 1)$(tput bold)FAILED$(tput sgr0)->$(tput setaf 2)$(tput bold)RETRY$(tput sgr0)"
STRING_RUN_FORCE="        $(tput setaf 1)$(tput bold)FORCE$(tput sgr0)"


STRING_CLEAN_DONE="       $(tput setaf 5)$(tput bold)DONE$(tput sgr0)"
STRING_CLEAN_READY="      $(tput setaf 2)$(tput bold)READY$(tput sgr0)"
STRING_CLEAN_NOSCRIPT="   $(tput setaf 3)$(tput bold)NOSCRIPT$(tput sgr0)"
STRING_CLEAN_FAILED="     $(tput setaf 1)$(tput bold)FAILED$(tput sgr0)"
STRING_CLEAN_FORCE="      $(tput setaf 1)$(tput bold)FORCE$(tput sgr0)"



function printHELP {
echo "------------------------------------------------------------------------"
echo "$(tput bold) $pname : cacao task manager $(tput sgr0)"
echo "source : $0"
echo "------------------------------------------------------------------------"
echo ""
echo "Manages high-level deployment/execution tasks, such as directory setup, file downloads and script execution. Tasks are listed in a user-provided task list file, with a <TASKNAME> entry per line. Tasks can be either executed or cleaned/undone. Operation (execute or clean) are performed sequentially based on option (x/X for execute, c/C for clean) and curent completion status. Run without option to print current task completion status."
echo ""
echo "EXECUTE SCRIPTS"
echo "An execute-script must exist for each task. The script must be in the system PATH, and be named: "
echo "   cacaotask-<TASKNAME>"
echo "The corresponding clean-script (optional) is auto-generated by the execute-script."
echo ""
echo "Currently available cacaotask execute-scipts on this system :"

liststring="$( echo $PATH | tr ':' '\0' | xargs -0 ls 2> /dev/null | grep "cacaotask-" | sort )"
filearray=($(echo $liststring | tr ";" "\n"))

#Print the split string
for scriptfile in "${filearray[@]}"
do
    printf " %-30s in %s\n" "${scriptfile}" "$(which ${scriptfile})"
done

echo ""
echo ""
echo "Required user-provided files/directories :"
echo "   <confname>-conf               [directory]   Configuration directory"
echo "   <confname>-conf/LOOPNAME      [ASCII file]  Loop name"
echo "   <confname>-conf/WORKDIR       [ASCII file]  Work directory name, will be created"
echo "   <confname>-conf/tasklist.txt  [ASCII file]  List of tasks to be executed"
echo ""
echo "Each task has a run-status and a clean-status."
echo "----------  run-status ------------"
echo "  ${STRING_RUN_DONE} : task has been successfully executed."
echo "  ${STRING_RUN_READY} : task is ready to be executed."
echo "  ${STRING_RUN_NOSCRIPT} : no script found for task -> Cannot be executed."
echo "  ${STRING_RUN_FAILED} : task failed on last execution attempt. Will try again."
echo "---------- clean-status ------------"
echo "    ${STRING_CLEAN_DONE} : cleanup completed successfully"
echo "    ${STRING_CLEAN_READY} : ready for task cleanup"
echo "    ${STRING_CLEAN_NOSCRIPT} : no cleanup script exists"
echo "    ${STRING_CLEAN_FAILED} : last cleanup failed"
echo ""
echo " $(tput bold)USAGE:$(tput sgr0)"
echo "     $USAGESTRING"
echo ""
echo " $(tput bold)OPTIONS:$(tput sgr0)"
echo "     $(tput bold)-h$(tput sgr0)            (h)elp and exit"
echo "     $(tput bold)-x$(tput sgr0)            e(x)ecute next ready task"
echo "     $(tput bold)-X$(tput sgr0) <step>     e(X)ecute all ready task down to and including step"
echo "     $(tput bold)-c$(tput sgr0)            (c)clean/undo last task"
echo "     $(tput bold)-C$(tput sgr0) <step>     (C)lean/undo all tasks up to and including step"
echo "     $(tput bold)-f$(tput sgr0) <step>     (f)orce task to run/clean: ignore status"
echo ""
echo "------------------------------------------------------------------------"
}


printHELP1 ()
{
    printf "%20s       run CACAO example\n" "$0" 
}


EXITSTATUS=0



function checkFile {
if [ -f $1 ]
  then
    echo "[$(tput setaf 2)$(tput bold)   OK   $(tput sgr0)] File $(tput bold)$1$(tput sgr0) found"
   else
    echo "[$(tput setaf 1)$(tput bold) FAILED $(tput sgr0)] File $(tput bold)$1$(tput sgr0) not found"
    EXITSTATUS=1
fi
}


function checkFileCreate {
if [ -f $1 ]
  then
    echo "[$(tput setaf 2)$(tput bold)   OK   $(tput sgr0)] File $(tput bold)$1$(tput sgr0) found"
   else
    echo "[$(tput setaf 3)$(tput bold)  INFO  $(tput sgr0)] File $(tput bold)$1$(tput sgr0) not found: Creating"
    touch $1
fi
}

function checkFileInfoOptional {
if [ -f $1 ]
  then
    echo "[$(tput setaf 2)$(tput bold)   OK   $(tput sgr0)] File $(tput bold)$1$(tput sgr0) found"
   else
    echo "[$(tput setaf 3)$(tput bold)  INFO  $(tput sgr0)] Optional file $(tput bold)$1$(tput sgr0) not found"
fi
}


function checkDir {
if [ -d $1 ]
  then
    echo "[$(tput setaf 2)$(tput bold)   OK   $(tput sgr0)] Directory $(tput bold)$1$(tput sgr0) found"
   else
    echo "[$(tput setaf 1)$(tput bold) FAILED $(tput sgr0)] Directory $(tput bold)$1$(tput sgr0) not found"
    EXITSTATUS=1
fi
}


function cmdexists()
{
  command -v "$1" >/dev/null 2>&1
}


function checkCommand {
if cmdexists $1; then
	if [ ${QUIET} = 0 ]; then
		echo "[$(tput setaf 2)$(tput bold)   OK   $(tput sgr0)] Command $(tput bold)$1$(tput sgr0) found"
    fi
    COMMAND_FOUND=1
else
	if [ ${QUIET} = 0 ]; then
		echo "[$(tput setaf 1)$(tput bold) FAILED $(tput sgr0)] Command $(tput bold)$1$(tput sgr0) not installed.  Aborting."
    fi
    COMMAND_FOUND=0
    EXITSTATUS=1;
fi
}











# ================= OPTIONS =============================
# Transform long options to short ones
singlelinehelp=0
for arg in "$@"; do
  shift
  case "$arg" in
    "--help") set -- "$@" "-h" ;;
    "--help1") 
set -- "$@" "-h" 
singlelinehelp=1;
;;
    *)        set -- "$@" "$arg"
  esac
done


CLEANMODE=0
EXECMODE=0

SINGLETASK=0
FORCE=0
FORCEINDEX=0
LASTTASK=1000


while getopts :hxX:cC:f: FLAG; do
  case $FLAG in
    h)  #show help
      if [ "$singlelinehelp" -eq "0" ]; then
      printHELP
      else
      printHELP1
      fi
      exit
      ;;
    x) # run next task
    EXECMODE=1
    SINGLETASK=1
    ;;
    X) # run all tasks    
    EXECMODE=1
    LASTTASK=${OPTARG}
    ;;
    c) # clean single task
    CLEANMODE=1
    SINGLETASK=1
    ;;
    C) # clean all tasks
    CLEANMODE=1
    LASTTASK=${OPTARG}
    ;;
    f)
    FORCE=1
    FORCEINDEX=${OPTARG}
    ;;
    \?) #unrecognized option - show help
      echo -e \\n"Option $OPTARG not allowed."
      printHELP
      ;;
  esac
done
shift $((OPTIND-1))  




if [ "$#" -ne $NBARGS ]; then
    echo "$(tput setaf 1)$(tput bold) Illegal number of parameters ($NBARGS params required, $# entered) $(tput sgr0)"
	echo "Usage :"
	echo "  $USAGESTRING"
	echo ""
    exit
fi



echo ""
echo "Checking required commands :"
checkCommand xterm
checkCommand tmux


echo ""
echo "Checking required files :"

CONFNAME="$1"

CONFDIR="${CURRENTDIR}/${CONFNAME}-conf"
checkDir ${CONFDIR}

LOOPNAMEFILE="${CONFDIR}/LOOPNAME"
checkFile ${LOOPNAMEFILE}
if [ -f $LOOPNAMEFILE ]; then
LOOPNAME="$(cat $LOOPNAMEFILE)"
fi

WORKDIRFILE="${CONFDIR}/WORKDIR"
checkFile ${WORKDIRFILE}
if [ -f $WORKDIRFILE ]; then
WORKDIRECTORY="${CURRENTDIR}/$(cat $WORKDIRFILE)"
WORKDIRECTORYLOCAL="$(cat $WORKDIRFILE)"
fi


TASKLISTFILE="${CONFDIR}/tasklist.txt"
checkFile ${TASKLISTFILE}


CACAOVARSFILE="${CONFDIR}/cacaovars.${LOOPNAME}.bash"
checkFile ${CACAOVARSFILE}


FPSSETUPFILE="${CONFDIR}/fpssetup.setval.${LOOPNAME}.conf"
checkFile ${FPSSETUPFILE}



if [ $EXITSTATUS = 1 ]; then
exit
fi



# log directory
# keeps track of what has been executed
#
LOGDIR="${CURRENTDIR}/${LOOPNAME}-log"
mkdir -p $LOGDIR












# Execute task
#
function task_EXEC {
	LOGRUNFILE="${LOGDIR}/task.${TASKCODE}.RUN"
	
	ENVOUTFILE="${LOGDIR}/task.${TASKCODE}.ENVOUT.bash"	
	touch ${ENVOUTFILE}
	
	CLEANSCRIPT="${LOGDIR}/task.${TASKCODE}.CLEAN.bash"
	echo "#!/bin/bash" > ${CLEANSCRIPT}
	chmod a+x ${CLEANSCRIPT}
	sleep 0.1
	
	source ${EXECfile}
	
	if [ ${cacaotask_RETURNCODE} = ${CACAOTASK_RUN_SUCCESS} ]; then
		# success
		touch "${LOGDIR}/task.${TASKCODE}.RUN.DONE"
	else
		# failure
		echo "${CACAOTASK_RUN_SUCCESS}" > "${LOGDIR}/task.${TASKCODE}.RUN.FAILED"
	fi
	
	mv -f ${LOGDIR}/task.${TASKCODE}.CLEAN.DONE ${LOGDIR}/task.${TASKCODE}.CLEAN.DONE.arch &> /dev/null
	mv -f ${LOGDIR}/task.${TASKCODE}.CLEAN.FAILED ${LOGDIR}/task.${TASKCODE}.CLEAN.FAILED.arch &> /dev/null
}


function task_SKIP {
	ENVOUTFILE="${LOGDIR}/task.${TASKCODE}.ENVOUT.bash"
	source ${ENVOUTFILE}
}


function task_CLEAN {
	LOGCLEANFILE="${LOGDIR}/task.${TASKCODE}.CLEAN"
	#CLEANTASK="NULL"
	
	source ${LOGDIR}/task.${TASKCODE}.CLEAN.bash
	
	rm ${LOGDIR}/task.${TASKCODE}.RUN.DONE &> /dev/null	
	rm ${LOGDIR}/task.${TASKCODE}.RUN.FAILED &> /dev/null
	
	# success
	touch ${LOGDIR}/task.${TASKCODE}.CLEAN.DONE
	
	# failure
	#touch "${LOGDIR}/task.${TASKCODE}.CLEAN.FAILED"
}





#
# READ TASK(S) TO BE EXECUTED FROM FILE
#

TASKCODEARRAY=( )
TASKDESCRARRAY=( )

function join { local IFS=" "; shift; echo "$*"; }


readarray -t TASKARRAY < ${TASKLISTFILE}

for taskarrayline in "${TASKARRAY[@]}";do
	taskline=(${taskarrayline}:)
	if [ ${#taskline} -gt 1 ]; then
		if [ ${taskline:0:1} != "#" ]; then
			TASKCODEARRAY+=( "${taskline[0]}" )
			TASKDESCRARRAY+=( "$(join ${taskline[@]})" )
		fi
	fi
done






echo ""
echo " CONFIGURATION : ${CONFNAME}"
echo ""
echo "    LOOPNAME           : $LOOPNAME"
echo "    CURRENTDIR         : $CURRENTDIR"
echo "    CONFDIR            : $CONFDIR"
echo "    WORKDIRECTORY      : ${WORKDIRECTORY}"
echo "    WORKDIRECTORYLOCAL : ${WORKDIRECTORYLOCAL}"
echo "    LOGDIR             : $LOGDIR"
echo ""



function READ_STATUS {

	QUIET=1

	RUNSTATUSARRAY=( )
	CLEANSTATUSARRAY=( )

	#
	# READ STATUS
	#
	tindex=0
	for TASKCODE in ${TASKCODEARRAY[@]}; do
	# RUN
	#	DONE     : task has been executed
	#	READY    : task has not yet been executed
	#   NOSCRIPT : task run script is missing
	#   FAILED   : task has failed
	#
	# RUN file exists ?
	#
	RUNSCRIPT="cacaotask-${TASKCODE}"
	STATUS="???"	
	checkCommand ${RUNSCRIPT}
	#if [ ! -f ${RUNSCRIPT} ]; then
	if [ ${COMMAND_FOUND} = 0 ]; then
		STATUS="NOSCRIPT"
		echo "$(tput setaf 1)$(tput bold) ERROR NOSCRIPT $(tput sgr0)cannot find script ${RUNSCRIPT}. Ensure it is in PATH"
	else
		STATUS="READY"  # default
	
		RUNLOGFILE="${LOGDIR}/task.${TASKCODE}.RUN.DONE"
		if [ -f ${RUNLOGFILE} ]; then
			STATUS="DONE"
		fi
		
		RUNLOGFILE="${LOGDIR}/task.${TASKCODE}.RUN.FAILED"
		if [ -f ${RUNLOGFILE} ]; then
			STATUS="FAILED"
		fi
		
		if [ ${FORCE} = 1 ]; then
			if [ "${STATUS}" != "READY" ]; then
				if [ ${tindex} = ${FORCEINDEX} ]; then
					STATUS="FORCE"
				fi	
			fi
		fi
	fi
	RUNSTATUSARRAY+=( "${STATUS}" )

	# CLEAN
	#   DONE     : clean done
	#	READY    : ready for cleanup (script exists)
	#   NOSCRIPT : script does not exist
	#   FAILED   : clean failed
	#
	# clean script exists ?
	#
	CLEANSCRIPT="${LOGDIR}/task.${TASKCODE}.CLEAN.bash"
	STATUS="???"
	if [ ! -f ${CLEANSCRIPT} ]; then
		STATUS="NOSCRIPT"
	else		
		STATUS="READY"  # default
		
		CLEANLOGFILE="${LOGDIR}/task.${TASKCODE}.CLEAN.DONE"
		if [ -f ${CLEANLOGFILE} ]; then
			STATUS="DONE"
		fi
		
		CLEANLOGFILE="${LOGDIR}/task.${TASKCODE}.CLEAN.FAILED"
		if [ -f ${CLEANLOGFILE} ]; then
			STATUS="FAILED"
		fi
		
		if [ ${FORCE} = 1 ]; then
			if [ "${STATUS}" != "READY" ]; then
				if [ ${tindex} = ${FORCEINDEX} ]; then
					STATUS="FORCE"
				fi	
			fi
		fi
	fi
	CLEANSTATUSARRAY+=( "${STATUS}" )
	let tindex+=1
	done
}



#
# print current status
#




function PRINT_STATUS {
	echo ""
	printf "    %18s    %12s  %12s\n" "TASK" "RUN STATUS" "CLEAN STATUS"
	echo "----------------------------------------------------------"
	for i in ${!TASKCODEARRAY[@]};
	do
	TASKCODE="${TASKCODEARRAY[$i]}"
	CLEANSTAT="${CLEANSTATUSARRAY[$i]}"
	
	RUNSTAT="${RUNSTATUSARRAY[$i]}"
	RUNSTATSTRING="${RUNSTAT}"
	if [ "${RUNSTAT}" = "DONE" ]; then
		RUNSTATSTRING="${STRING_RUN_DONE}"
	fi
	if [ "${RUNSTAT}" = "READY" ]; then
		RUNSTATSTRING="${STRING_RUN_READY}"
	fi
	if [ "${RUNSTAT}" = "NOSCRIPT" ]; then
		RUNSTATSTRING="${STRING_RUN_NOSCRIPT}"
	fi
	if [ "${RUNSTAT}" = "FAILED" ]; then
		RUNSTATSTRING="${STRING_RUN_FAILED}"
	fi
	if [ "${RUNSTAT}" = "FORCE" ]; then
		RUNSTATSTRING="${STRING_RUN_FORCE}"
	fi
	
	
	CLEANSTAT="${CLEANSTATUSARRAY[$i]}"
	CLEANSTATSTRING="${CLEANSTAT}"
	if [ "${CLEANSTAT}" = "DONE" ]; then
		CLEANSTATSTRING="${STRING_CLEAN_DONE}"
	fi
	if [ "${CLEANSTAT}" = "READY" ]; then
		CLEANSTATSTRING="${STRING_CLEAN_READY}"
	fi	
	if [ "${CLEANSTAT}" = "NOSCRIPT" ]; then
		CLEANSTATSTRING="${STRING_CLEAN_NOSCRIPT}"
	fi	
	if [ "${CLEANSTAT}" = "FAILED" ]; then
		CLEANSTATSTRING="${STRING_CLEAN_FAILED}"
	fi	
	if [ "${CLEANSTAT}" = "FORCE" ]; then
		CLEANSTATSTRING="${STRING_CLEAN_FORCE}"
	fi
		
	printf "%2d  %18s    %8s  %8s   ${TASKDESCRARRAY[$i]}\n" "${i}" "${TASKCODE}" "${RUNSTATSTRING}" "${CLEANSTATSTRING}"
 done
}








READ_STATUS
PRINT_STATUS


NBTASKDONE=0

echo ""
#
# EXECUTE TASKS
#
let TASKINDEX=0
for i in ${!TASKCODEARRAY[@]};
do
	TASKCODE="${TASKCODEARRAY[$i]}"
	
	if [ "${TASKINDEX}" -gt "${LASTTASK}" ]; then
		EXECMODE=0
	fi
	
	if [ ${EXECMODE} = 1 ]; then				
		if [ "${RUNSTATUSARRAY[$i]}" = "DONE" ]; then
			ENVOUTFILE="${LOGDIR}/task.${TASKCODE}.ENVOUT.bash"	
			printf "%s %20s  sourcing %s\n"  "   $(tput bold)SKIP$(tput sgr0)" "$TASKCODE" "${ENVOUTFILE} "
			task_SKIP
		fi
		
		if [ "${RUNSTATUSARRAY[$i]}" = "READY" ] || [ "${RUNSTATUSARRAY[$i]}" = "FAILED" ]|| [ "${RUNSTATUSARRAY[$i]}" = "FORCE" ]; then
			EXECfile=$( which cacaotask-${TASKCODE} )
			printf "%s %20s  executing %s\n"  "$(tput rev)EXECUTE$(tput sgr0)" "$TASKCODE" "${EXECfile} "
			task_EXEC
			let NBTASKDONE+=1
			if [ ${SINGLETASK} = 1 ]; then
				EXECMODE=0
			fi
		fi
	
	fi
	let TASKINDEX+=1
done


#
# CLEAN TASKS
#
# scan backward for cleanup
let TASKINDEX-=1
until [  ${TASKINDEX} -lt 0 ]; do
	TASKCODE="${TASKCODEARRAY[${TASKINDEX}]}"

	if [ "${TASKINDEX}" -lt "${LASTTASK}" ]; then
		CLEANMODE=0
	fi

	if [ ${CLEANMODE} = 1 ]; then
		if [ "${CLEANSTATUSARRAY[${TASKINDEX}]}" = "READY" ] || [ "${CLEANSTATUSARRAY[${TASKINDEX}]}" = "FORCE" ]; then
			echo "    $(tput rev)CLEAN$(tput sgr0)    $TASKCODE"
			task_CLEAN
			let NBTASKDONE+=1
			if [ ${SINGLETASK} = 1 ]; then
				CLEANMODE=0
			fi
		fi
	fi
	let TASKINDEX-=1
done



if [ ${NBTASKDONE} = 0 ]; then
	echo "No task performed"
else
	echo "${NBTASKDONE} task(s) performed"
	sync

	READ_STATUS
	PRINT_STATUS
fi




